---
title: Lucky @ Flagyard
date: 2025-10-04 04:45:00 +0800
categories: [CTF, Flagyard]
tags: [writeups, binary exploitation, pwn]
math: true
mermaid: true
media_subpath: /assets/posts/2025-10-04-Flagyard
image:
  path: preview.jpeg
---

## Lucky - Flagyard
Difficulty: Easy

Overview: **Lucky** chains a stack-reuse bug to force a local variable to attacker-controlled values, allowing bypass of safety checks. That bypass triggers an out-of-bounds write which lets you corrupt critical memory. A separate libc leak reveals a libc address so you can compute the base and turn the OOB write into full code execution.

### Basic File Checks
First all we do some basic file checks to see the security protections enabled on the binary. 
```
mcsam@0x32:~/Desktop/ctf/flagyard/pwn/lucky$ checksec --file lucky
[*] '/home/mcsam/Desktop/ctf/flagyard/pwn/lucky/lucky'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
```

The binary is 64 bit little endian and the build lacks stack canaries, which lets us overwrite the saved return address on the stack. Also we can see that PIE is enabled.


### Decompiling and identifying vulnerabilities
The binary is stripped, meaning it contains no symbol information to explain functions or variables. As a result we must reverse engineer names and annotate the decompiled output by hand so the program logic is easy to follow.
```
mcsam@0x32:~/Desktop/ctf/flagyard/pwn/lucky$ file lucky
lucky: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=1ef13a48326a28ecbf0cc6fcaa356cedec9d00d5, for GNU/Linux 3.2.0, stripped
```

Let's start off by running the binary to analyse it's behaviour. 
```
mcsam@0x32:~/Desktop/ctf/flagyard/pwn/lucky$ ./lucky
Welcome to the 100 percent accurate lucky number generator. You will definitely win the lottery with this number generator.
1. Enter your name and birthday
2. Generate numbers
> 1
Enter your name: mcsam
Enter your birth year: 9
Enter your birth month: 9
Enter your birth day: 9
Hello mcsam
, your ID is 11464902665060
Welcome to the 100 percent accurate lucky number generator. You will definitely win the lottery with this number generator.
1. Enter your name and birthday
2. Generate numbers
> 2
Oh it's your first time here? I'll give you more lucky numbers than usual!
NUM 8
Your lucky numbers are:
60
56
5
14
54
38
62
88
How many numbers do you want to change?
3
Enter new number: 2
Enter new number: 3
Enter new number: 4
```

The program is an interactive lucky number generator with a simple menu. Option one asks for name and birthday and prints a generated ID. Option two produces a set of lucky numbers, prints an extra message the first time it is used, and then lets you overwrite a chosen number of generated values.

Now that we’ve observed the program’s behavior, we can start static analysis and decompilation in IDA to map out its logic and find the bugs. Because the binary is stripped, I renamed functions and variables in my decompilation to make the logic easier to follow. You will not see the same names if you load the binary into IDA.

In the decompilation of the main function, the `setup()` function is called firstly. It then enters a menu loop driven by `show_menu()`. If the user chooses `1`, `gen_user_id()` is called; if they choose `2` , `gen_lucky_numbers()` is called. Any other input causes th program to exit. 
```bash
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  int user_menu_choice; // [rsp+Ch] [rbp-4h]

  setup();
  while ( 1 )
  {
    while ( 1 )
    {
      user_menu_choice = show_menu();
      if ( user_menu_choice != 1 )
        break;
      gen_user_id(a1, a2);
    }
    if ( user_menu_choice != 2 )
      exit(1);
    gen_lucky_numbers(a1, a2);
  }
}
```

Let's see what the `show_menu()` function does. 
```bash
__int64 show_menu()
{
  unsigned int v1; // [rsp+Ch] [rbp-4h] BYREF

  printf(
    "Welcome to the 100 percent accurate lucky number generator. You will definitely win the lottery with this number gen"
    "erator.\n"
    "1. Enter your name and birthday\n"
    "2. Generate numbers\n"
    "> ");
  __isoc99_scanf("%d", &v1);
  return v1;
}
```

The `show_menu()` function displays the program’s main menu and reads the user’s choice using `scanf("%d", &v1)`. It then returns that integer to the caller. This return value is used in `main()` to decide which feature to execute, either generating a user ID (`gen_user_id`) or producing the lucky numbers (`gen_lucky_numbers`).

#### Analysing the the `gen_user_id` function
Now that we know what the main function is doing let's take a look at the `gen_user_id` function. By doing a quick analysis we can identify this function helps to generate an ID/seed.
```bash
int gen_user_id()
{
  int v0; // eax
  __int64 birth_day; // [rsp+8h] [rbp-68h] BYREF
  __int64 birth_month; // [rsp+10h] [rbp-60h] BYREF
  __int64 birth_year; // [rsp+18h] [rbp-58h] BYREF
  char username[76]; // [rsp+20h] [rbp-50h] BYREF
  int counter; // [rsp+6Ch] [rbp-4h]

  counter = 0;
  printf("Enter your name: ");
  memset(username, 0, 64uLL);
  username[read(0, username, 63uLL)] = 0;
  printf("Enter your birth year: ");
  __isoc99_scanf("%ld", &birth_year);
  printf("Enter your birth month: ");
  __isoc99_scanf("%ld", &birth_month);
  printf("Enter your birth day: ");
  __isoc99_scanf("%ld", &birth_day);
  while ( counter <= 7 )
  {
    v0 = counter++;
    *(_QWORD *)&seed ^= *(_QWORD *)&username[8 * v0];
  }
  *(_QWORD *)&seed ^= birth_day;
  *(_QWORD *)&seed ^= birth_month;
  *(_QWORD *)&seed ^= birth_year;
  return printf("Hello %s, your ID is %ld\n", username, *(_QWORD *)&seed);
}
```

The `gen_user_id` function reads a username and three integers for birth year month and day. It zeros the first 64 bytes of the username buffer then reads up to 63 bytes from `stdin` and explicitly writes a terminating zero at the read length. After collecting the inputs the function computes a seed by XORing eight consecutive eight byte blocks taken from the username into seed in a loop that runs from zero to seven, and then XORing the birth day month and year into seed. Finally it prints the username and the computed seed.

One interesting observation is that, depending on the input values provided to this function, it is possible to make the computed seed equal to 0. This happens because the seed is derived entirely through XOR operations, and with carefully chosen inputs these operations can cancel each other out, resulting in a zero seed value.

#### Analysing the the `gen_lucky_numbers` function
The `gen_lucky_numbers` function allows the generation of a set of random numbers which rely on the seed produced by `gen_user_id`. Take a look at the decomplation below. 
```bash
__int64 gen_lucky_numbers()
{
  __int64 result; // rax
  int i; // [rsp+0h] [rbp-30h] BYREF
  int j; // [rsp+4h] [rbp-2Ch]
  int max_number_of_nums_to_change; // [rsp+8h] [rbp-28h]
  int number_of_nums_to_change; // [rsp+Ch] [rbp-24h] BYREF

  if ( *(_QWORD *)&seed )
    max_number_of_nums_to_change = 4;
  if ( dword_4010 )
  {
    puts("Oh it's your first time here? I'll give you more lucky numbers than usual!");
    max_number_of_nums_to_change = 8;
    dword_4010 = 0;
  }
  printf("NUM %d\n", max_number_of_nums_to_change);
  puts("Your lucky numbers are:");
  srand(seed);
  for ( i = 0; i < max_number_of_nums_to_change; ++i )
  {
    *(&i + i + 4) = rand() % 100;
    printf("%d\n", *(&i + i + 4));
  }
  puts("How many numbers do you want to change?");
  __isoc99_scanf("%d", &number_of_nums_to_change);// write to first element of the array
  result = (unsigned int)max_number_of_nums_to_change;// convert v3 to an unsigned integer
  if ( number_of_nums_to_change <= max_number_of_nums_to_change )
  {
    for ( j = 0; ; ++j )
    {
      result = (unsigned int)number_of_nums_to_change;
      if ( j >= number_of_nums_to_change )
        break;
      printf("Enter new number: ");
      __isoc99_scanf("%d", &i + j + 4);
    }
  }
  return result;
}
```

When we examine the code to understand its behavior, one thing we notice is a condition that checks whether the seed value has been set. From the `gen_user_id` function, we already know that the seed can be influenced by our input. By carefully choosing those inputs, we can control the seed value and even set it to zero, which allows us to bypass this check entirely.


On **line 11** there's another check on `dword_4010` which is an uninitialized global variable. Uninitialized globals default to zero. Inside the branch that runs when `dword_4010` is zero the program initializes `max_number_of_nums_to_change` and assigns a value to `dword_4010`. Tf we skip that branch by passing the earlier seed check, those variables remain uninitialized. 

> One thing to note is that when we call two functions let's say function A and B in succession then if function B contains uninitilized local variables then the stack frame for function A will be reused and this will result in values for local variables in function A being used for function B.
{: .prompt-tip }
